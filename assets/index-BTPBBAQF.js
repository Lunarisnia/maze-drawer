var b=Object.defineProperty;var C=(e,t,i)=>t in e?b(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i;var h=(e,t,i)=>C(e,typeof t!="symbol"?t+"":t,i);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const c of a.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function i(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerPolicy&&(a.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?a.credentials="include":n.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(n){if(n.ep)return;n.ep=!0;const a=i(n);fetch(n.href,a)}})();class l{constructor(t,i){h(this,"x");h(this,"y");this.x=t,this.y=i}zero(){return this.x==0&&this.y==0}subtract(t){return new l(this.x-t.x,this.y-t.y)}length(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2))}}const y=(e,t,i)=>Math.max(t,Math.min(e,i));class g{static paint(t,i,s,n,a,c){const u={white:1,red:2,green:3,blue:4,black:0},d=t.getBoundingClientRect(),r=new l(i.clientX-d.left,i.clientY-d.top),o=y(Math.floor(r.x/a),0,n-1),f=y(Math.floor(r.y/a),0,n-1);s.set(o,f,u[c]),s.dump()}}class v{constructor(t){h(this,"size");h(this,"matrix");h(this,"start",null);h(this,"end",null);this.size=t,this.matrix=Array.from(Array(this.size),i=>Array(this.size).fill(0))}set(t,i,s){s!=1&&(this.start&&(this.start.x!=t||this.start.y!=i)&&s==2&&(this.matrix[this.start.y][this.start.x]=0),this.end&&(this.end.x!=t||this.end.y!=i)&&s==3&&(this.matrix[this.end.y][this.end.x]=0),this.start&&this.start.x==t&&this.start.y==i&&s==0&&(this.start=null),this.end&&this.end.x==t&&this.end.y==i&&s==0&&(this.end=null),s==2&&(this.start=new l(t,i)),s==3&&(this.end=new l(t,i))),!(s==1&&(this.matrix[i][t]==2||this.matrix[i][t]==3))&&(this.matrix[i][t]=s)}dump(){let t="";for(const i of this.matrix){for(const s of i)t+=s+" ";t+=`
`}console.log(t)}clear(){this.matrix=Array.from(Array(this.size),t=>Array(this.size).fill(0)),this.start=null,this.end=null}scan(){for(let t=0;t<this.matrix.length;t++)for(let i=0;i<this.matrix[t].length;i++)this.matrix[t][i]==2&&(this.start=new l(i,t)),this.matrix[t][i]==3&&(this.end=new l(i,t))}reset(){for(let t=0;t<this.matrix.length;t++)for(let i=0;i<this.matrix[t].length;i++)this.matrix[t][i]==4&&(this.matrix[t][i]=1);this.start&&(this.matrix[this.start.y][this.start.x]=2),this.end&&(this.matrix[this.end.y][this.end.x]=3)}}class w{constructor(t,i){h(this,"ctx");h(this,"canvas");h(this,"rectBound");h(this,"mousePosition",null);h(this,"mazeSize");h(this,"matrix");h(this,"brushSize",8);h(this,"painting",!1);h(this,"brush");h(this,"brushColor");this.canvas=document.querySelector("#myCanvas"),this.canvas.height=i*t,this.canvas.width=i*t,this.ctx=this.canvas.getContext("2d"),this.rectBound=this.canvas.getBoundingClientRect(),this.brush=new g,this.mazeSize=t,this.matrix=new v(t),this.brushSize=i,this.brushColor="white",this.matrix.matrix=[[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0],[0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,0,0,1,1,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0],[0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0],[1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,0,1,1],[1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0],[1,0,1,0,1,0,0,1,0,0,2,1,1,1,1,1,1,0,1,0],[1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1],[0,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],[0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1],[0,1,1,1,1,0,1,0,1,0,0,1,0,1,0,0,0,0,1,0],[1,1,1,0,1,0,1,0,1,1,1,0,3,0,1,1,1,0,1,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,1,0],[1,0,1,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0],[1,0,1,0,1,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1]],this.matrix.scan(),this.canvas.addEventListener("mousemove",s=>{this.mousePosition=new l(s.clientX,s.clientY),this.painting&&(this.brushColor=="white"||this.brushColor=="black")&&g.paint(this.canvas,s,this.matrix,this.mazeSize,this.brushSize,this.brushColor)}),this.canvas.addEventListener("mouseout",()=>{this.mousePosition=null,this.painting=!1}),this.canvas.addEventListener("mousedown",s=>{g.paint(this.canvas,s,this.matrix,this.mazeSize,this.brushSize,this.brushColor),this.painting=!0}),this.canvas.addEventListener("mouseup",s=>{this.painting=!1})}brushHighlight(){if(this.mousePosition){const t=new l(this.mousePosition.x-this.rectBound.left,this.mousePosition.y-this.rectBound.top),i=Math.floor(t.x/this.brushSize),s=Math.floor(t.y/this.brushSize);this.ctx.beginPath(),this.ctx.rect(i*this.brushSize,s*this.brushSize,this.brushSize,this.brushSize),this.ctx.fillStyle=this.brushColor,this.ctx.fill()}}render(){for(let t=0;t<this.matrix.matrix.length;t++)for(let i=0;i<this.matrix.matrix[t].length;i++){switch(this.ctx.beginPath(),this.ctx.rect(i*this.brushSize,t*this.brushSize,this.brushSize,this.brushSize),this.matrix.matrix[t][i]==0?this.ctx.fillStyle="black":this.ctx.fillStyle="white",this.matrix.matrix[t][i]){case 1:this.ctx.fillStyle="white";break;case 2:this.ctx.fillStyle="red";break;case 3:this.ctx.fillStyle="green";break;case 4:this.ctx.fillStyle="blue";break;default:this.ctx.fillStyle="black"}this.matrix.start&&this.matrix.start.x==i&&this.matrix.start.y==t&&(this.ctx.fillStyle="red"),this.matrix.end&&this.matrix.end.x==i&&this.matrix.end.y==t&&(this.ctx.fillStyle="green"),this.ctx.fill()}}clearCanvas(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}changeBrushColor(t){this.brushColor=t}reset(){this.matrix.clear()}}function m(e,t){return`
    <button type="button" id="${e}">
        ${t}
    </button>
    `}class z{constructor(t,i,s,n){h(this,"maze");h(this,"start");h(this,"end");h(this,"pixelCanvas");this.maze=t,this.start=i,this.end=s,this.pixelCanvas=n}}class B{constructor(t,i,s,n,a,c){h(this,"finalCost");h(this,"startCost");h(this,"endCost");h(this,"passable");h(this,"position");h(this,"parent");this.finalCost=i,this.startCost=s,this.endCost=n,this.passable=a,this.position=c,this.parent=t}}class S{constructor(){h(this,"heap",[])}getParentIndex(t){return Math.floor((t-1)/2)}getLeftChildIndex(t){return 2*t+1}getRightChildIndex(t){return 2*t+2}swap(t,i){const s=this.heap[t];this.heap[t]=this.heap[i],this.heap[i]=s}heapifyUp(){let t=this.heap.length-1;for(;this.getParentIndex(t)>=0&&this.heap[this.getParentIndex(t)].finalCost>this.heap[t].finalCost;)this.swap(t,this.getParentIndex(t)),t=this.getParentIndex(t)}heapifyDown(){let t=0;for(;this.getLeftChildIndex(t)<this.heap.length;){let i=this.getLeftChildIndex(t);if(this.getRightChildIndex(t)<this.heap.length&&this.heap[this.getRightChildIndex(t)].finalCost<this.heap[i].finalCost&&(i=this.getRightChildIndex(t)),this.heap[t].finalCost<=this.heap[i].finalCost)break;this.swap(t,i),t=i}}insert(t){for(const i of this.heap)if(i==t)return;this.heap.push(t),this.heapifyUp()}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1)return this.heap.pop();const t=this.heap[0];return this.heap[0]=this.heap.pop(),this.heapifyDown(),t}peek(){return this.heap.length>0?this.heap[0]:void 0}size(){return this.heap.length}}function P(e){const t=[];for(let i=0;i<e;i++){const s=[];for(let n=0;n<e;n++)s.push(new B(null,0,0,0,!1,new l(n,i)));t.push(s)}return t}function M(e){const t=[];for(let i=0;i<e;i++){const s=[];for(let n=0;n<e;n++)s.push(!1);t.push(s)}return t}function I(e,t,i){return e>=0&&e<i&&t>=0&&t<i}class L extends z{solve(){if(!this.start||!this.end)return[this.maze,!0];const t=P(this.maze.length);for(let r=0;r<t.length;r++)for(let o=0;o<t.length;o++)t[r][o].startCost=this.start.subtract(new l(o,r)).length(),t[r][o].endCost=this.end.subtract(new l(o,r)).length(),t[r][o].finalCost=t[r][o].startCost+t[r][o].endCost,t[r][o].passable=this.maze[r][o]!=0;const i=M(this.maze.length),s=new S,n=[[-1,0],[1,0],[0,-1],[0,1]];s.insert(t[this.start.y][this.start.x]);let a=null;const c=r=>{if(i[r.position.y][r.position.x]=!0,this.maze[r.position.y][r.position.x]=4,r.position.x==this.end.x&&r.position.y==this.end.y){a=r;return}for(const o of n){const f=r.position.x+o[1],x=r.position.y+o[0];if(I(f,x,this.maze.length)&&!i[x][f]){const p=t[x][f];p.passable&&(p.parent=r,s.insert(p))}}if(s.size()>0)c(s.extractMin());else return};if(c(s.extractMin()),!a)return[this.maze,!0];this.pixelCanvas.matrix.reset();const u=[],d=r=>{r&&(u.push(r.position),d(r.parent))};d(a);for(let r=u.length-1;r>=0;r--){const o=u[r];this.maze[o.y][o.x]=4}return[this.maze,!1]}}document.querySelector("#app").innerHTML=`
  <h2>
    Maze Solver
  </h2>
  <span>Draw your own maze and the magic algorithm will try and solve it. (<a href="https://github.com/Lunarisnia/maze-drawer">Source Code</a>)</span>
  <div>
    <canvas id="myCanvas" width="24" height="24" style="border:1px solid #000000;">
    </canvas>
  </div>
  <p>Change Brush</p>
  ${m("RedBrush","ðŸŸ¥ Maze Starting Point")}
  ${m("GreenBrush","ðŸŸ© Maze Ending Point")}
  ${m("WhiteBrush","â¬œ Maze Path")}
  ${m("BlackBrush","Black Wall")}
  <div>
    <br>
    <br>
    <button id="resetButton">Reset</button>
    <button id="solveButton">Solve</button>
  </div>
`;const E=e=>new Promise(t=>setTimeout(t,e)),k=20;async function R(){const e=new w(k,16);for(document.getElementById("RedBrush").addEventListener("click",()=>{e.changeBrushColor("red")}),document.getElementById("WhiteBrush").addEventListener("click",()=>{e.changeBrushColor("white")}),document.getElementById("GreenBrush").addEventListener("click",()=>{e.changeBrushColor("green")}),document.getElementById("BlackBrush").addEventListener("click",()=>{e.changeBrushColor("black")}),document.getElementById("resetButton").addEventListener("click",()=>{e.reset()}),document.getElementById("solveButton").addEventListener("click",()=>{const t=new L(e.matrix.matrix,e.matrix.start,e.matrix.end,e);e.matrix.reset();const[i,s]=t.solve();e.matrix.matrix=i,e.matrix.dump()});;)e.render(),e.brushHighlight(),await E(1),e.clearCanvas()}R().then(e=>e);
